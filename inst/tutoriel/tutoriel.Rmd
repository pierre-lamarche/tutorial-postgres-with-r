---
title: "Tutoriel : utiliser une instance Postgres avec R"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(knitr)
library(learnr)
knitr::opts_chunk$set(echo = TRUE)
```

## Objectif du tutoriel

Ce tutoriel illustre la connexion depuis `R` à une instance Postgres qui contient les données du Recensement de Population 2016, disponibles sur le [site de l'Insee](https://www.insee.fr/fr/statistiques/4171558). L'instance en question a été déployée sur la plateforme Onyxia du SSPCloud, et n'est accessible que depuis cette plateforme.

On montera quelques usages que l'on peut faire à partir de cette instance et en quoi combiner `R` et Postgres est utile.

## Pourquoi utiliser une base de données

Les données du Recensement de Population sont assez volumineuses ; pour les données de 2016, elles représentent environ 63 Go. Il est par conséquent illusoire de vouloir travailler avec l'ensemble de ces données chargées simultanément en mémoire avec `R`. La seule table `logement` contient 25 millions de lignes et peut déjà représenter une difficulté pour certaines machines. Ces contraintes d'espace tombent avec un système de base de données. 

## Comment utiliser une base de données avec `R`

### Se connecter à la base Postgres

Comme indiqué dans la [documentation UtilitR](https://linogaliana.gitlab.io/documentationR/se-connecter-%C3%A0-une-base-de-donn%C3%A9es.html#se-connecter-%C3%A0-une-base-de-donn%C3%A9es-1), il est possible d'utiliser différents *packages* pour se connecter à la base de données. Quelle que soit la solution utilisée, il faut disposer de cinq paramètres pour générer la connexion à la base de données :

* l'URL de la base de données, que l'on peut décrire comme l'adresse du serveur contenant la base de données ;
* le port de la base de données, une sorte de complément à l'adresse ;
* le nom de la base de données ;
* l'identifiant de connexion (souvent l'Idep, mais parfois autre chose), soit l'identité de la personne qui se connecte ;
* le mot de passe associé à l'identifiant.

Dans l'exemple qui nous intéresse, l'URL de la base de données est la suivante : 
```{r, echo = FALSE}
Sys.getenv("PGRP_HOST")
```
Le nom de la base de données est `rp`, le port `5432`. On se connecte avec un identifiant générique d'utilisateur, `user_read`. Cet identifiant a été créé pour permettre à tous ceux qui souhaitent se connecter à la base de données de le faire, sans toutefois leur permettre de modifier la base en question ; c'est pour cette raison qu'on parle *d'accès en lecture*. Le mot de passe, lui aussi partagé, est le suivant : `RP2016Insee`.

On va donc créer un objet `connexion` pour se connecter à la base de données, en utilisant les informations décrites ci-dessus, et en utilisant la fonction `dbConnect` du *package* `RPostgres`. C'est au travers de cet objet `connexion` qu'on va passer pour toutes les requêtes que l'on souhaite soumettre à la base de données. En utilisant le _package_ `RPostgres`, la connexion se fait de la manière suivante :

```{r connexion, exercise = TRUE}
### création d'un objet connexion
library(DBI)
connexion <- dbConnect(RPostgres::Postgres(),
                       host = "192.168.1.24",
                       dbname = "rp",
                       port = 5432,
                       user = "user_read",
                       password = "RP2016Insee")

### lister les tables du schéma rp2016
dbGetQuery(connexion, "select tablename from pg_catalog.pg_tables where schemaname = 'rp2016'")
```
Dans l'usage courant, il est fortement déconseillé d'inscrire "en dur" les identifiants de connexion tels que le mot de passe ou même l'identifiant. Utiliser des fonctions telles que `rstudio::askForPassword` permet un usage interactif du code, sans dévoiler des éléments confidentiels tels que les identifiants de connexion.

### Visualiser la base de données

Sous RStudio, il est possible de visualiser la structure de la base de données à laquelle on est connecté dans l'onglet `Connections` dans le panneau en haut à droite de l'écran.

```{r screenshot1, fig.cap = '', echo = FALSE, out.width = '80%'}
knitr::include_graphics("images/screenshot_connections_pane.png")
```

Pour cela, deux solutions :

* soit utiliser le _package_ `odbc` disponible sur le CRAN, mais qui nécessite l'installation de librairies sytème ;
* soit utiliser le _package `RPostgresInsee` que l'on peut installer avec la commande `remotes::install_github("pierre-lamarche/RPostgresInsee")`.

Dans le premier cas, le code pour créer la connexion avec la base de données se présente comme suit :

```{r odbc, collapse=FALSE, eval = FALSE}
library(DBI)
connexion <- dbConnect(odbc::odbc(),
                       driver = "Postgres Unicode",
                       server = "192.168.1.24",
                       database = "rp",
                       port = 5432,
                       uid = "user_read",
                       pwd = "RP2016Insee")
```

Dans le second cas, la syntaxe est légèrement différente (mais très proche de celle utilisée pour le _package_ `RPostgres`) :

```{r postgresinsee, collapse=FALSE, eval = FALSE}
library(DBI)
connexion <- dbConnect(RPostgresInsee::Postgres(),
                       host = "192.168.1.24",
                       dbname = "rp",
                       port = 5432,
                       user = "user_read",
                       password = "RP2016Insee")
```

## Réaliser des requêtes dans la base de données

Pour soumettre des requêtes sur la base de données à partir de `R` une fois la connexion établie, il existe deux solutions :

* utiliser le langage SQL, qui est le langage propre aux bases de données. Les fonctions `dbSendQuery` et `dbGetQuery` ;
* utiliser le _package_ `dbplyr`, qui permet de recourir à une syntaxe très similaire à celle de `tidyverse`.

### En langage SQL

À partir du _package_ `DBI`, il est possible de soumettre des requêtes SQL sur la base de données en utilisant deux fonctions de ce _package_, la fonction `dbSendQuery` pour laquelle on soumet une requête sans en récupérer le résultat, et la fonction `dbGetQuery` pour laquelle on récupère le résultat.

Ainsi, par exemple, sur les données du RP, on peut créer une table intermédiaire - stockée dans le base de données - pour laquelle on crée une indicatrice pour chaque logement sur le fait d'être une résidence principale ou non. Puis on récupère en mémoire le nombre de résidences principales par département.

```{r res_princ, exercise = TRUE}
library(DBI)
connexion <- dbConnect(RPostgres::Postgres(),
                       host = "192.168.1.24",
                       dbname = "rp",
                       port = 5432,
                       user = "user_read",
                       password = "RP2016Insee")

### création d'une table temporaire avec une indicatrice résidence principale par logement
dbSendQuery(connexion, "create temp table res_princ as
            select substr(commune, 1, 2) as departement, case 
              when catl = '1' then 1
              else 0
            end as res_princ
            from rp2016.logement")
### récupération de la somme par département de l'indicatrice
compte_rp <- dbGetQuery(connexion, "select distinct departement, sum(res_princ) as nb_res_princ 
                        from res_princ group by departement")
compte_rp
```

### Le package `dbplyr`

Le _package_ permet à l'utilisateur familier de la syntaxe `tidyverse` d'envoyer des requêtes vers la base de données en adoptant cette syntaxe, qui est ensuite traduite par le programme en requête SQL. Ainsi, pour réaliser la même opération que précédemment, voici comment on peut procéder avec le _package_ en question :

```{r res_pinc2, exercise = TRUE}
library(DBI)
library(dplyr)
library(dbplyr)
connexion <- dbConnect(RPostgres::Postgres(),
                       host = "192.168.1.24",
                       dbname = "rp",
                       port = 5432,
                       user = "user_read",
                       password = "RP2016Insee")

### repérer la table logement dans le schéma rp2016
logement <- tbl(connexion, in_schema("rp2016", "logement"))

### création d'une table temporaire avec une indicatrice résidence principale par logement
res_princ <- logement %>%
  mutate(departement = substr(commune, 1, 2),
         res_princ = ifelse(catl == '1', 1, 0)) %>%
  select(departement, res_princ) %>%
  compute()
### récupération de la somme par département de l'indicatrice
compte_rp <- res_princ %>%
  group_by(departement) %>%
  summarise(nb_res_princ = sum(res_princ)) %>%
  collect()
compte_rp
```

Dans `dbplyr`, la commande `collect()` permet de récupérer en mémoire le résultat de la collecte, et s'apparente donc à `dbGetQuery` dans `DBI`. Il est également intéressant de noter qu'il est possible de visualiser sur la fonction `show_query` qui permet de visualiser l'interpréation de la commande en requête SQL. Pour rentrer dans la mécanique SQL, l'utilisateur familier de la syntaxe `tidyverse` pourra s'appuyer sur la fonction `translate_sql` qui permet de traduire en SQL la syntaxe `tidyverse`.

```{r show_query, warning = FALSE, message = FALSE, exercise = TRUE}
library(DBI)
library(dplyr)
library(dbplyr)
connexion <- dbConnect(RPostgres::Postgres(),
                       host = "192.168.1.24",
                       dbname = "rp",
                       port = 5432,
                       user = "user_read",
                       password = "RP2016Insee")

### repérer la table logement dans le schéma rp2016
logement <- tbl(connexion, in_schema("rp2016", "logement"))

### création d'une table temporaire avec une indicatrice résidence principale par logement
res_princ <- logement %>%
  mutate(departement = substr(commune, 1, 2),
         res_princ = ifelse(catl == '1', 1, 0)) %>%
  select(departement, res_princ) %>%
  show_query()

```

### Exercice bonus

Il faut éviter autant que possible de récupérer les données volumineuses disponibles dans la base de données et de les charger en mémoire de `R`. Les traitements doivent être prioritairement réalisés 